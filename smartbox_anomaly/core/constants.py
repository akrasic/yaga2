"""
Shared constants and enumerations for the ML anomaly detection pipeline.

This module centralizes all magic values, enums, and constant definitions
to improve maintainability and reduce duplication.
"""

from __future__ import annotations

from enum import Enum
from typing import Final

# =============================================================================
# Enumerations
# =============================================================================


class AnomalySeverity(str, Enum):
    """Severity levels for detected anomalies."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

    @classmethod
    def from_string(cls, value: str) -> AnomalySeverity:
        """Convert string to severity enum, defaulting to MEDIUM."""
        try:
            return cls(value.lower())
        except (ValueError, AttributeError):
            return cls.MEDIUM

    @property
    def numeric_value(self) -> int:
        """Get numeric value for severity comparison."""
        return {
            self.LOW: 1,
            self.MEDIUM: 2,
            self.HIGH: 3,
            self.CRITICAL: 4,
        }[self]

    def __lt__(self, other: object) -> bool:
        if isinstance(other, AnomalySeverity):
            return self.numeric_value < other.numeric_value
        return NotImplemented

    def __le__(self, other: object) -> bool:
        if isinstance(other, AnomalySeverity):
            return self.numeric_value <= other.numeric_value
        return NotImplemented

    def __gt__(self, other: object) -> bool:
        if isinstance(other, AnomalySeverity):
            return self.numeric_value > other.numeric_value
        return NotImplemented

    def __ge__(self, other: object) -> bool:
        if isinstance(other, AnomalySeverity):
            return self.numeric_value >= other.numeric_value
        return NotImplemented


class IncidentStatus(str, Enum):
    """Status of an anomaly incident."""

    OPEN = "OPEN"
    CLOSED = "CLOSED"


class IncidentAction(str, Enum):
    """Actions taken on incidents during fingerprinting."""

    CREATE = "CREATE"
    CONTINUE = "CONTINUE"
    UPDATE = "UPDATE"
    RESOLVE = "RESOLVE"
    CLOSE = "CLOSE"
    NO_CHANGE = "NO_CHANGE"
    MIXED = "MIXED"


class TimePeriod(str, Enum):
    """Time periods for time-aware anomaly detection."""

    BUSINESS_HOURS = "business_hours"
    EVENING_HOURS = "evening_hours"
    NIGHT_HOURS = "night_hours"
    WEEKEND_DAY = "weekend_day"
    WEEKEND_NIGHT = "weekend_night"

    @classmethod
    def all_periods(cls) -> tuple[TimePeriod, ...]:
        """Return all time periods."""
        return tuple(cls)

    @property
    def is_weekend(self) -> bool:
        """Check if this period is a weekend period."""
        return self in (self.WEEKEND_DAY, self.WEEKEND_NIGHT)

    @property
    def is_night(self) -> bool:
        """Check if this period is a night period."""
        return self in (self.NIGHT_HOURS, self.WEEKEND_NIGHT)


class ServiceCategory(str, Enum):
    """Categories for service classification."""

    CRITICAL = "critical"
    STANDARD = "standard"
    MICRO = "micro"
    ADMIN = "admin"
    CORE = "core"
    BACKGROUND = "background"
    UNKNOWN = "unknown"


class ModelType(str, Enum):
    """Types of anomaly detection models."""

    TIME_AWARE = "time_aware"
    TIME_AWARE_EXPLAINABLE = "time_aware_explainable"
    TIME_AWARE_FALLBACK = "time_aware_fallback"
    STANDARD_ML = "standard_ml"
    EXPLAINABLE_ML = "explainable_ml"


class AlertType(str, Enum):
    """Types of alerts generated by the pipeline."""

    ANOMALY_DETECTED = "anomaly_detected"
    INCIDENT_RESOLVED = "incident_resolved"
    ERROR = "error"


class DetectionMethod(str, Enum):
    """Methods used for anomaly detection."""

    ISOLATION_FOREST = "isolation_forest"
    MULTIVARIATE = "multivariate"
    THRESHOLD = "threshold"
    PATTERN = "pattern"
    CORRELATION = "correlation"
    ENHANCED_ISOLATION_FOREST = "enhanced_isolation_forest"
    NAMED_PATTERN_MATCHING = "named_pattern_matching"
    ZERO_NORMAL_THRESHOLD = "zero_normal_threshold"
    FAST_FAIL = "fast_fail"


# =============================================================================
# Metric Constants
# =============================================================================


class MetricName:
    """Standard metric names used in the pipeline."""

    REQUEST_RATE: Final[str] = "request_rate"
    APPLICATION_LATENCY: Final[str] = "application_latency"
    CLIENT_LATENCY: Final[str] = "client_latency"
    DATABASE_LATENCY: Final[str] = "database_latency"
    ERROR_RATE: Final[str] = "error_rate"

    @classmethod
    def core_metrics(cls) -> tuple[str, ...]:
        """Return the core metrics used for anomaly detection."""
        return (
            cls.REQUEST_RATE,
            cls.APPLICATION_LATENCY,
            cls.CLIENT_LATENCY,
            cls.DATABASE_LATENCY,
            cls.ERROR_RATE,
        )

    @classmethod
    def zero_normal_metrics(cls) -> tuple[str, ...]:
        """Return metrics where zero is a normal/expected value."""
        return (cls.CLIENT_LATENCY, cls.DATABASE_LATENCY)

    @classmethod
    def latency_metrics(cls) -> tuple[str, ...]:
        """Return all latency-related metrics."""
        return (cls.APPLICATION_LATENCY, cls.CLIENT_LATENCY, cls.DATABASE_LATENCY)


# =============================================================================
# Threshold Constants
# =============================================================================


class Thresholds:
    """Threshold constants for anomaly detection."""

    # Isolation Forest score thresholds for severity mapping
    CRITICAL_SCORE: Final[float] = -0.6
    HIGH_SCORE: Final[float] = -0.3
    MEDIUM_SCORE: Final[float] = -0.1

    # Input validation bounds
    MAX_REQUEST_RATE: Final[float] = 1_000_000.0  # Max 1M req/sec
    MAX_LATENCY_MS: Final[float] = 300_000.0  # Max 5 minutes
    MAX_ERROR_RATE: Final[float] = 1.0  # Max 100%

    # Training thresholds
    MIN_TRAINING_SAMPLES: Final[int] = 50
    MIN_MULTIVARIATE_SAMPLES: Final[int] = 100
    CONSTANT_VALUE_THRESHOLD: Final[float] = 1e-10

    # Percentile thresholds
    OUTLIER_LOWER_PERCENTILE: Final[float] = 0.001
    OUTLIER_UPPER_PERCENTILE: Final[float] = 0.999

    @classmethod
    def score_to_severity(cls, score: float) -> AnomalySeverity:
        """Map an isolation forest score to severity level."""
        if score < cls.CRITICAL_SCORE:
            return AnomalySeverity.CRITICAL
        if score < cls.HIGH_SCORE:
            return AnomalySeverity.HIGH
        if score < cls.MEDIUM_SCORE:
            return AnomalySeverity.MEDIUM
        return AnomalySeverity.LOW


# =============================================================================
# Time Period Constants
# =============================================================================


# Fallback period priorities when primary period model is unavailable
PERIOD_FALLBACK_MAP: Final[dict[str, tuple[str, ...]]] = {
    TimePeriod.BUSINESS_HOURS.value: (
        TimePeriod.EVENING_HOURS.value,
        TimePeriod.WEEKEND_DAY.value,
        TimePeriod.NIGHT_HOURS.value,
        TimePeriod.WEEKEND_NIGHT.value,
    ),
    TimePeriod.NIGHT_HOURS.value: (
        TimePeriod.WEEKEND_NIGHT.value,
        TimePeriod.EVENING_HOURS.value,
        TimePeriod.BUSINESS_HOURS.value,
        TimePeriod.WEEKEND_DAY.value,
    ),
    TimePeriod.EVENING_HOURS.value: (
        TimePeriod.BUSINESS_HOURS.value,
        TimePeriod.WEEKEND_DAY.value,
        TimePeriod.NIGHT_HOURS.value,
        TimePeriod.WEEKEND_NIGHT.value,
    ),
    TimePeriod.WEEKEND_DAY.value: (
        TimePeriod.BUSINESS_HOURS.value,
        TimePeriod.EVENING_HOURS.value,
        TimePeriod.WEEKEND_NIGHT.value,
        TimePeriod.NIGHT_HOURS.value,
    ),
    TimePeriod.WEEKEND_NIGHT.value: (
        TimePeriod.NIGHT_HOURS.value,
        TimePeriod.WEEKEND_DAY.value,
        TimePeriod.EVENING_HOURS.value,
        TimePeriod.BUSINESS_HOURS.value,
    ),
}

# Time confidence scores by period (higher = more reliable detection)
PERIOD_CONFIDENCE_SCORES: Final[dict[str, float]] = {
    TimePeriod.BUSINESS_HOURS.value: 0.9,
    TimePeriod.NIGHT_HOURS.value: 0.95,
    TimePeriod.EVENING_HOURS.value: 0.8,
    TimePeriod.WEEKEND_DAY.value: 0.7,
    TimePeriod.WEEKEND_NIGHT.value: 0.6,
}


# =============================================================================
# Service Classification Patterns
# =============================================================================


# Patterns for auto-detecting service categories from names
SERVICE_CATEGORY_PATTERNS: Final[dict[ServiceCategory, tuple[str, ...]]] = {
    ServiceCategory.CRITICAL: ("api", "gateway", "proxy", "auth", "login"),
    ServiceCategory.ADMIN: ("admin", "adm", "management", "mgmt"),
    ServiceCategory.BACKGROUND: ("worker", "job", "task", "queue", "processor"),
    ServiceCategory.MICRO: ("micro", "util", "helper", "tool"),
    ServiceCategory.CORE: ("m2-", "core", "platform", "db", "database", "cache"),
}


# =============================================================================
# Model Suffixes
# =============================================================================


# Time period suffixes used in model directory names
TIME_PERIOD_SUFFIXES: Final[tuple[str, ...]] = (
    "_business_hours",
    "_evening_hours",
    "_night_hours",
    "_weekend_day",
    "_weekend_night",
    "_weekend",  # Legacy 4-period compatibility
)
